#pragma config(Sensor, dgtl1,  coneArm,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  liftSensor,     sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           fRbR,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           fLbL,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           chainArm,      tmotorVex393_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port6,           lift,          tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl7)
#pragma config(Motor,  port7,           bottomRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           bottomLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topLeft,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
int auton = 1;

void displayAuton(){
	switch(auton){
	case 1:
		displayLCDCenteredString(0, "Auto1");

		break;
	case -1:
		displayLCDCenteredString(0, "Auto2");

		break;
	case 0:
		displayLCDCenteredString(0, "Auto3");

		break;
	default:
		displayLCDCenteredString(0, "No auton");

		break;
	}
}

task LCDControl()
{
	clearLCDLine(0);
	clearLCDLine(1);
	bool noButtonsPressed = true;
	displayAuton();
	while(true){
		if(noButtonsPressed){ // only update auton if a button is pressed AND wasn't pressed previously
			switch(nLCDButtons){
			case kButtonLeft:
				auton--;
				displayAuton();
				break;
			case kButtonCenter:
				stopTask(LCDControl);
				break;
			case kButtonRight:
				auton++;
				displayAuton();
				break;
			}
		}
		noButtonsPressed = !nLCDButtons; //update if there is a button currently pressed
		wait1Msec(20);
	}
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
void sensorSet(){
	SensorType[dgtl1] = sensorNone;
	SensorType[dgtl1] = sensorQuadEncoder;
	SensorType[dgtl7]= sensorNone;
	SensorType[dgtl7]= sensorQuadEncoder;
}
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;
	startTask(LCDControl);

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
	sensorSet();
	SensorValue[coneArm]  = 0;
	SensorValue[liftSensor] = 0;
}
//7 inch cone; 4 inches half height


task autonomous()
{
	stopTask(LCDControl);
	switch(auton){
	case 1:
		motor(chainArm) = 57;
		wait1Msec(500);// arm goes up
		motor(chainArm) = 0;
		while (SensorValue[liftSensor] > -20){
			motor(topRight) = -57;
			motor(topLeft) = -57;
			motor(bottomLeft) = -57;
			motor(bottomRight) = -57;
		}
		motor(lift) = -50;
		wait1Msec(1000);//lift the elevator while lowering th mogo
		motor(chainArm) = 0;
		motor(topRight) = 0;
		motor(topLeft) = 0;
		motor(bottomLeft) = 0;
		motor(bottomRight) = 0;
		motor(fLbL) = 127;
		motor(fRbR) = 127;
		wait1Msec(2300);//drive forward
		motor(lift) = 87;
		motor(fLbL) = 0;
		motor(fRbR) = 0;
		wait1Msec(1500);//bring up lift
		motor(topRight) = 67;
		motor(topLeft) = 67;
		motor(bottomLeft) = 67;
		motor(bottomRight) = 67;
		wait1Msec(300);//lower the elevator
		motor(topRight) = 0;
		motor(topLeft) = 0;
		motor(bottomLeft) = 0;
		motor(bottomRight) = 0;
		motor(fLbL) = -127;
		motor(fRbR) = -127;
		motor(lift) = 0;
		motor(intake) = 100;
		wait1Msec(2700);//back up while dropping the ball
		motor(fLbL) = 67;
		motor(fRbR) = -67;
		motor(intake) = 0;
		wait1Msec(675);//turn to line up with the pole
		motor(fLbL) = 127;
		motor(fRbR) = 127;
		wait1Msec(500);//go forward a bit
		motor(fLbL) = 67;
		motor(fRbR) = -67;
		wait1Msec(1200);//360 time
		motor(fLbL) = 127;
		motor(fRbR) = 127;
		wait1Msec(1000);//into the 20
		motor(lift) = -127;
		wait1Msec(1750);//take the mogo down
		motor(fLbL) = -127;
		motor(fRbR) = -127;
		motor(lift) = 67;
		while(SensorValue[coneArm] > 1){
			motor(chainArm) = -27;
		}
		wait1Msec(500);//backup out of 20
		break;

	case 2:
		motor(chainArm) = 57;
		wait1Msec(500);
		motor(fLbL && fRbR) = 127;
		motor(chainArm) = 0;
		motor(topRight) = -67;
		motor(topLeft) = -67;
		motor(bottomLeft) = -67;
		motor(bottomRight) = -67;
		wait1Msec(1000);//drive foward while moving lift up to position
		motor(fLbL && fRbR) = 0;
		motor(topRight) = 0;
		motor(topLeft) = 0;
		motor(bottomLeft) = 0;
		motor(bottomRight) = 0;
		motor(intake) = 100;
		wait1Msec(650); //keep the lift up while the intake goes in reverse, drive stops
		motor(fLbL && fRbR) = -127;
		wait1Msec(500);//drive back from pole
		break;

	case -1:
		//add auto
		break;

	default:
		break;
	}
}

task driverControl() {
	stopTask(LCDControl);
	while(true) {
		motor(fRbR) = vexRT[Ch3] + vexRT[Ch4];
		motor(fLbL) = vexRT[Ch3] - vexRT[Ch4];
	}
}

task usercontrol() {

	int stackComplete = 0;
	bool pressed = false;
	int motorSwitch = 1;
	//int armState = 1;
	int coneArray[] = {55, 60, 65, 70, 75, 80, 84, 89, 94, 99};
	int liftArray[] = {-13, -20, -28, -34, -42, -50, -58, -64, -66, -66};
	int count = 0;

	bool stackFlag = true;

	motor(bottomLeft) = 0;
	motor(bottomRight) = 0;
	motor(topRight) = 0;
	motor(topLeft) = 0;

	while(true)	{
		motor(fRbR) = (vexRT[Ch3] * motorSwitch) + vexRT[Ch4];
		motor(fLbL) = (vexRT[Ch3] * motorSwitch) - vexRT[Ch4];

		motor(lift) = (126 * vexRT[Btn6D]) - (126 * vexRT[Btn6U]);

		motor(chainArm) = ((126 * vexRT[Btn7U])) - ((126 * vexRT[Btn7D]));

		motor(bottomLeft) = vexRT[Ch2];
		motor(bottomRight) = vexRT[Ch2];
		motor(topRight) = vexRT[Ch2];
		motor(topLeft) = vexRT[Ch2];

		//semi autostack
		if(vexRT[Btn8D]) {
			count = 0;
		}
		if(vexRT[Btn8U]) {
			if(!pressed) {
				count--;
			}
			pressed = true;
			} else {
			pressed = false;
		}
		if(vexRT[Btn5U]) {
			startTask(driverControl);
			//lower cone intake
			while(SensorValue[coneArm] < 155) {
				motor(chainArm) = 126;
				motor(intake) = -70;
			}
			motor(chainArm) = -20;
			wait1Msec(200);

			while(SensorValue[coneArm] > 133) {
				motor(chainArm) = -126;
			}
			motor(chainArm) = -20;
			wait1Msec(200);

			while(SensorValue[liftSensor] > liftArray[count]) {
				if(count > 6) {
					motor(bottomLeft) = -100;
					motor(bottomRight) = -100;
					motor(topRight) = -100;
					motor(topLeft) = -100;
				}
				else {
					motor(bottomLeft) = -70;
					motor(bottomRight) = -70;
					motor(topRight) = -70;
					motor(topLeft) = -70;
				}
			}
			motor(bottomLeft) = 5;
			motor(bottomRight) = 5;
			motor(topRight) = 5;
			motor(topLeft) = 5;
			wait1Msec(190);
			motor(bottomLeft) = 0;
			motor(bottomRight) = 0;
			motor(topRight) = 0;
			motor(topLeft) = 0;


			while(SensorValue[coneArm] > coneArray[count]) {
				motor(chainArm) = -100;
				motor(bottomLeft) = -15;
				motor(bottomRight) = -15;
				motor(topRight) = -15;
				motor(topLeft) = -15;
			}
			motor(chainArm) = 35;
			wait1Msec(200);

			motor(chainArm) = 0;

			motor(bottomLeft) = 25;
			motor(bottomRight) = 25;
			motor(topRight) = 25;
			motor(topLeft) = 25;
			wait1Msec(500);

			motor(intake) = 87;
			wait1Msec(600);

			motor(bottomLeft) = -30;
			motor(bottomRight) = -30;
			motor(topRight) = -30;
			motor(topLeft) = -30;
			motor(intake) = 127;
			wait1Msec(400);

			while(SensorValue[coneArm] < 128) {
				motor(chainArm) = 40;
			}
			motor(chainArm) = -10;
			wait1Msec(200);
			motor(chainArm) = 0;

			motor(bottomLeft) = 35;
			motor(bottomRight) = 35;
			motor(topRight) = 35;
			motor(topLeft) = 35;
			wait1Msec(500);
			stopTask(driverControl);
			count++;
		}
		motor(intake) = (126 * vexRT[Btn8L]) - (126 * vexRT[Btn8R]) - 27;
	}
}


